# SPRING.V4
Goal:  "Spring Security를 적용한 나만의 블로그 백엔드 서버 만들기"

---

## 요구사항

1. 회원 가입 API
    
2. 로그인 API
       
3. 전체 게시글 목록 조회 API
   - 게시글/댓글에 ‘좋아요’ 개수도 함께 반환하기

4. 게시글 작성 API
   - ~~토큰을 검사하여, 유효한 토큰일 경우에만 게시글 작성 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   
5. 선택 게시글 조회 API
   - 게시글/댓글에 ‘좋아요’ 개수도 함께 반환하기
   
6. 선택 게시글 수정 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 수정 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 제목, 작성 내용을 수정하고 수정된 게시글을 Client 로 반환하기
   - 게시글에 ‘좋아요’ 개수도 함께 반환하기
   
7. 선택한 게시글 삭제 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 삭제 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 게시글을 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기
   
8. 댓글 작성 API
   - ~~토큰을 검사하여, 유효한 토큰일 경우에만 댓글 작성 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 게시글의 DB 저장 유무를 확인하기
   - 선택한 게시글이 있다면 댓글을 등록하고 등록된 댓글 반환하기
   
9. 댓글 수정 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 수정 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 댓글의 DB 저장 유무를 확인하기
   - 선택한 댓글이 있다면 댓글 수정하고 수정된 댓글 반환하기
   - 댓글에 ‘좋아요’ 개수도 함께 반환하기
   
10. 댓글 삭제 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 삭제 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 댓글의 DB 저장 유무를 확인하기
   - 선택한 댓글이 있다면 댓글 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기

11. 예외 처리
   - 토큰이 필요한 API 요청에서 토큰을 전달하지 않았거나 정상 토큰이 아닐 때는 "토큰이 유효하지 않습니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 토큰이 있고, 유효한 토큰이지만 해당 사용자가 작성한 게시글/댓글이 아닌 경우에는 “작성자만 삭제/수정할 수 있습니다.”라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - DB에 이미 존재하는 username으로 회원가입을 요청한 경우 "중복된 username 입니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 로그인 시, 전달된 username과 password 중 맞지 않는 정보가 있다면 "회원을 찾을 수 없습니다."라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 회원가입 시 username과 password의 구성이 알맞지 않으면 에러메시지와 statusCode: 400을 Client에 반환하기

[//]: # (---)

[//]: # (## Use Case & ERD & API 명세서)

[//]: # ()
[//]: # (   [Notion 바로가기]&#40;&#41;)

---

1. Spring Security를 적용했을 때 어떤 점이 도움이 되셨나요?
   - 사용자 인증, 권한 부여, 세션 관리, 암호화 등의 보안 기능을 일관되게 사용할 수 있으며, 보안 관련 로직을 반복해서 구현하지 않아도 된다는 장점이 있었습니다. 보안 관련 이벤트 핸들러 등록이나 테스트의 경우도 장점이라고 하는데 아직 체감하지 못했습니다.
   
2. Spring Security를 사용하지 않는다면 어떻게 인증/인가를 효율적으로 처리할 수 있을까요?
   - 커스텀 보안 프레임워크: Apache Shiro, JSecurity, JAAS(Java Authentication and Authorization Service) 등이 있습니다. 이러한 프레임워크를 사용하여 인증 및 인가를 처리할 수 있으며, 프레임워크의 특징과 기능을 활용할 수 있습니다.
   - 서드파티 인증/인가 서비스: OAuth, OpenID Connect 등과 같은 서드파티 인증/인가 서비스를 활용할 수 있습니다. 이러한 서비스를 사용하여 사용자의 인증 및 인가를 처리하고, 인증 서비스에서 제공하는 토큰을 사용하여 자체적으로 인증 및 인가를 처리할 수 있습니다.
   
3. AOP에 대해 설명해 주세요!
   - AOP(Aspect-Oriented Programming)은 프로그래밍 패러다임 중 하나로 애플리케이션의 핵심 비즈니스 로직과 공통으로 발생하는 부가적인 기능을 분리하여 모듈화하는 방법입니다. AOP를 사용하면 애플리케이션에서 공통 관심사를 분리하여 모듈화할 수 있으며, 코드의 중복을 줄이고 유지보수성을 향상시킬 수 있습니다. 대표적인 AOP 프레임워크로는 Spring Framework의 Spring AOP가 있습니다.
   
4. RefreshToken 적용에 대한 장/단점을 작성해 주세요! 적용해 보지 않으셨다면 JWT를 사용하여 인증/인가를 구현 했을 때의 장/단점에 대해 숙련주차의 답변을 Upgrade 하여 작성해 주세요!

   - 장점
     - 보안 향상: Refresh Token은 Access Token을 발급하는 과정에서 노출되는 시간을 최소화하므로, 악의적인 공격자에 대한 보호 수준을 높일 수 있습니다.
     - 장기적인 로그인 유지: Refresh Token은 일정 기간 동안 유효하므로, 사용자가 애플리케이션에 장기간 로그인한 상태를 유지할 수 있습니다. 사용자는 Access Token이 만료되더라도 Refresh Token을 사용하여 새로운 Access Token을 얻을 수 있습니다.
     - 사용자 경험 개선: Refresh Token을 사용하면 사용자가 일정 시간마다 로그인해야 하는 번거로움을 줄일 수 있습니다. 사용자는 자동으로 새로운 Access Token을 얻어 로그인 상태를 유지할 수 있습니다.
   
   - 단점
     - 보안 고려 사항: Refresh Token은 Access Token보다 장기적인 유효성을 갖기 때문에, 안전하게 저장 및 관리되어야 합니다. Refresh Token이 노출되면 악의적인 사용자가 액세스 권한을 남용할 수 있으므로, 적절한 보안 대책이 필요합니다.
     - 추가 복잡성: Refresh Token을 구현하려면 애플리케이션의 인증 및 세션 관리 로직에 대한 추가적인 구현이 필요합니다. 이로 인해 코드의 복잡성이 증가할 수 있습니다.
     - 세션 관리 비용: Refresh Token을 사용하면 인증 및 세션 관리에 필요한 서버 리소스 및 데이터베이스 조작이 증가할 수 있습니다. 따라서 대규모 애플리케이션에서는 성능 및 확장성에 영향을 줄 수 있습니다.
   
5. 즉시로딩 / 지연로딩에 대해 설명해 주세요!

   - 즉시로딩(Eager Loading):
   즉시로딩은 연관된 객체를 한 번에 모두 로딩하는 방식입니다. 즉시로딩은 객체 그래프를 한 번에 로딩하여 성능상 이점을 가지지만, 데이터베이스에서 불필요한 JOIN이 발생할 수 있고, 데이터의 양이 많을 경우 부하가 발생할 수 있습니다.

   - 지연로딩(Lazy Loading):
   지연로딩은 연관된 객체가 실제로 사용될 때까지 로딩을 지연시키는 방식입니다. 지연로딩은 필요한 순간에만 데이터를 로딩하여 데이터베이스 부하를 줄이고 성능을 향상시킬 수 있습니다. 그러나 객체 그래프를 여러 번 접근할 경우 추가적인 데이터베이스 쿼리가 발생하여 성능 저하가 발생할 수 있습니다.

즉시로딩은 객체 그래프를 한 번에 로딩하여 성능을 향상시키지만, 데이터베이스 부하가 커질 수 있습니다. 반면에 지연로딩은 필요한 순간에 데이터를 로딩하여 데이터베이스 부하를 줄이지만, 추가적인 데이터베이스 쿼리가 발생할 수 있습니다. 이를 고려하여 애플리케이션의 성능, 사용자 경험, 데이터베이스 부하 등을 고려하여 적절한 로딩 전략을 선택해야 합니다.